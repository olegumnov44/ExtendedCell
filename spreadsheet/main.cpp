#include "test/tests.h"
#include "test/test_runner_p.h"

using namespace std;

int main() {
    TestRunner tr;

    RUN_TEST(tr, TestPositionAndStringConversion);
    RUN_TEST(tr, TestPositionToStringInvalid);
    RUN_TEST(tr, TestStringToPositionInvalid);
    RUN_TEST(tr, TestEmpty);
    RUN_TEST(tr, TestInvalidPosition);
    RUN_TEST(tr, TestSetCellPlainText);
    RUN_TEST(tr, TestClearCell);
    RUN_TEST(tr, TestFormulaArithmetic);
    RUN_TEST(tr, TestFormulaReferences);
    RUN_TEST(tr, TestFormulaExpressionFormatting);
    RUN_TEST(tr, TestFormulaReferencedCells);
    RUN_TEST(tr, TestErrorValue);
    RUN_TEST(tr, TestErrorDiv0);
    RUN_TEST(tr, TestEmptyCellTreatedAsZero);
    RUN_TEST(tr, TestFormulaInvalidPosition);
    RUN_TEST(tr, TestPrint);
    RUN_TEST(tr, TestCellReferences);
    RUN_TEST(tr, TestFormulaIncorrect);
    RUN_TEST(tr, TestCellCircularReferences);

    RUN_TEST(tr, TestDiv0);
    RUN_TEST(tr, TestPrint_01);
    RUN_TEST(tr, Test_01);

    return 0;
}

/*
--Задание
В заготовке кода вы найдёте файлы:

    Файл Formula.g4. В файл с грамматикой добавлен новый вид операнда CELL.
        Он может состоять из последовательности заглавных латинских букв и последовательности цифр.
    Файл common.h. 1. Добавлены описания новых исключений: InvalidPositionException, FormulaException,
        CircularDependencyException. 2. В класс FormulaError добавлено поле category_ —
        это типы ошибок вычисления. Возможные значения поля: Ref, Value, Div0. 3.
        В интерфейс CellInterface добавлен метод GetRefferencedCells(), который возвращает позиции всех ячеек,
        входящих в формулу. 4. В классе CellInterface указано возможное значение ячейки:
        using Value = std::variant<std::string, double, FormulaError>.
    Файл FormulaAST.cpp. Добавлен новый дочерний класс CellExpr : Expr.
        Реализуйте для него метод Evaluate(args). Также реализуйте этот метод для всех
        остальных дочерних классов класса Expr. Поменяйте сигнатуру метода.
    Файлы cell.h и cell.cpp. Добавьте новые поля и методы.
    Файлы sheet.h и sheet.cpp. Добавьте новые поля и методы в соответствии с вашим дизайном классов.
    Файл main.cpp. Содержит возможные тесты.

Скопируйте содержимое файлов CMakeLists.txt, FindANTLR.cmake Formula.g4, common.h, FormulaAST.h,
    FormulaAST.cpp, formula.h, cell.h, main.cpp и test_runner.h ниже и вставьте в своё решение.

--Задание (для ревью)
В этом уроке мы продвинемся дальше и добавим в формулы новые операнды — индексы ячеек.
Формула сможет выглядеть так: “=A1*3+4/B2”.

Нужно будет изменить классы FormulaAST, Formula, Cell, Sheet: создать в них ссылки друг на друга,
написать новые методы, поправить сигнатуры существующих. Это большой объём работы.

Вы получите файлы с интерфейсами common.h и formula.h, а также описание тех изменений в классе FormulaAST.
В качестве основы используйте решение из предыдущей части задания.

--Электронная таблица
Вы по-прежнему работаете с электронной таблицей — хранилищем ячеек. Ячейки могут быть текстовыми
и формульными и задаются методом Cell::Set(std::string). Текст, задающий формульную ячейку,
по-прежнему начинается со знака равенства “=”.
Однако теперь операндами формулы могут быть не только числа, но и индексы других ячеек, например: “=1+A2”.

--Вычисление значений в ячейках
Рассмотрим пример. В ячейке С2 записана формула “=A3/A2”. Чтобы её вычислить,
надо разделить значение ячейки А3 на значение ячейки А2.
В ячейке А3 находится формула “=1+2*7”. Её легко вычислить: это 15.
В ячейке A2 находится текст “3”. Формально ячейка не формульная. Но её текст можно интерпретировать как число.
Поэтому предполагаем, что её значение 3.

Text:
        A       B       C       D       E
1
2         3            =A3/A2
3    =1+2*7
4

Value:
        A       B       C       D       E
1
2       3               5
3      15
4

Результат 15/3=5.
Если формула содержит индекс пустой ячейки, предполагаем, что значение пустой ячейки — 0.

Text:
        A       B       C       D       E
1
2       3            =A3/A2
3
4

Value:
        A       B       C       D       E
1
2       3               0
3       0
4

--Ошибки вычисления
В вычислениях могут возникнуть ошибки. Например, уже известная вам ошибка «‎деление на 0»‎.
Если делитель равен 0, значение ячейки — ошибка FormulaError типа #DIV0!

Text:
        A       B       C       D       E
1
2        0           =A3/A2
3   =1+2*7
4

Value:
        A       B       C       D       E
1
2       0             #DIV0!
3      15
4

Если ячейку, чей индекс входит в формулу, нельзя проинтерпретировать как число,
возникает ошибка нового типа: FormulaError — нет значения #VALUE! В следующем примере
в ячейке А2 находится текст, поэтому вычисление формулы в ячейке С2 (=А3/А2) вернёт эту ошибку.

Text:
        A       B       C       D       E
1
2     text           =A3/A2
3   =1+2*7
4

Value:
        A       B       C       D       E
1
2    text             #VALUE!
3      15
4

Формула может содержать ссылку на ячейку, которая выходит за границы возможного размера таблицы,
например С2 (=А1234567+ZZZZ1). Такая формула может быть создана, но не может быть вычислена,
поэтому её вычисление вернёт ошибку #REF!

Text:
        A       B       C       D       E
1
2                   =A3/ZZZ2
3  =1+2*7
4

Value:
        A       B       C       D       E
1
2                     #REF!
3      15
4

Ошибки распространяются вверх по зависимостям. В следующем примере формула в С4 зависит от С2 (=С2+8).
Формула в С2 выдала ошибку вычисления #VALUE! Значит, формула в С4 выдаст ту же ошибку при вычислении.

Text:
        A       B       C       D       E
1
2     text           =A3/A2
3   =1+2*7
4                     =C2+8

Value:
        A       B       C       D       E
1
2     text           #VALUE!
3       15
4                    #VALUE!

Точно так же распространяются ошибки #DIV0! и #REF! Если формула зависит от нескольких ячеек,
каждая из которых содержит ошибку вычисления, результирующая ошибка может соответствовать любой из них.

--Циклические зависимости
Таблица должна всегда оставаться корректной. Если ячейки циклически зависят друг от друга,
мы не сможем вычислить значения ячеек. Поэтому нельзя позволить, чтобы возникли циклические зависимости
между ячейками. То есть нельзя дать пользователю задать ячейку с формулой,
которая вводит циклические зависимости. Программа должна кидать исключение CircularDependencyException,
а ячейка не должна меняться.

Text:
        A       B       C       D       E
1
2       3            =A3/A2
3   =C4-1
4                     =C2+8

Если пользователь попытается ввести в А3 формулу “=C4-1”, программа должна кидать исключение и не менять ячейку А3.

--Требования к эффективности
Требования к эффективности таблицы остаются такими же, как в уроке Таблица.
Если размер минимальной печатной области равен K, то:
любой метод интерфейса SheetInterface должен работать за O(K);
метод Sheet::GetCell() — за O(1);
метод Cell::GetValue() — за O(K);
метод Cell::GetText() — за O(1);
повторный вызов метода Cell::GetValue(), если между вызовами значения ячеек,
от которых данная ячейка зависит напрямую или опосредованно, не менялись — за O(1);
повторный вызов метода Sheet::SetCell() с теми же аргументами — за O(1);
метод Cell::GetReferencedCells() возвращает индексы всех ячеек, которые входят в формулу — за O(1).
Возможные ошибки и исключения
Таблица должна работать корректно и устойчиво, а все компоненты должны быть согласованы.
Если пользователь вызывает методы с некорректными аргументами, программа не должна менять таблицу,
но должна кидать исключения. По ним пользователь может понять, что он сделал что-то не так.
Некоторые исключения вы уже реализовали в предыдущих заданиях.

В этом задании добавится одно новое исключение — циклическая зависимость.
Некорректная формула. Если в ячейку методомSheet::SetCell() пытаются записать
синтаксически некорректную формулу, например =A1+*, реализация должна выбросить исключение FormulaException,
а значение ячейки не должно измениться. Формула считается синтаксически некорректной,
если она не удовлетворяет предоставленной грамматике.
Некорректная позиция. Программно возможно создать экземпляр класса Position c некорректной позицией,
например (-1, -1). Если пользователь передаёт её в методы, программа должна кидать исключение
InvalidPositionException. Методы интерфейсов — например Cell::GetReferencedCells() —
всегда должны возвращать корректные позиции.
Циклическая зависимость. Если пользователь пытается в методе Sheet::SetCell() записать в ячейку формулу,
которая привела бы к циклической зависимости, реализация должна выбросить исключение
CircularDependencyException, а значение ячейки не должно измениться.

--Парсинг формул и ANTLR
В грамматике формулы появился новый операнд — индекс ячейки — CELL.
Он может принимать значения вроде А1, RD17. CELL добавлен в файл с грамматикой для ANTLR (Formula.4g)

В класс FormulaAST добавлен новый вид узла дерева CellExpr : Expr — индекс ячейки.
Для него пока не реализован метод Evaluate(). Вам предстоит его продумать.
При парсинге формулы в методе ParseFormulaAST мы сохраним все встреченные индексы ячеек в отдельный список.
Для этого в класс FormulaAST добавлено приватное поле  std::forward_list<Position> cells_.
В интерфейс CellInterface мы добавили метод CellInterface::GetReferencedCells().
Вам нужно будет реализовать его самим.

--Задание (Design)
Придумайте, как должно выглядеть новое решение. То есть создайте дизайн классов: их поля, методы,
ссылки друг на друга, сигнатуры методов.
Учтите, что нельзя менять методы интерфейсов FormulaInterface, CellInterface и SheetInterface.
Мы будем обращаться к ним при тестировании. Они же используются в файле main.cpp для проверки.

В файле common.h объявлены интерфейсы классов CellInterface и SheetInterface, а также ошибки и исключения.
Этот файл нельзя будет менять.

В файле formula.h объявлен интерфейс класса FormulaInterface. Его менять тоже нельзя.

Вы можете менять сами классы FormulaAST, Formula, Cell, Sheet.

Ваше решение должно ответить на следующие вопросы:
1) Как дерево вычислений FormulaAST будет вычислять значение для операнда CELL?
Дерево для вычислений FormulaAST из первой части может существовать отдельно от таблицы и ячеек.
Формула, состоящая из чисел, самодостаточна. Её можно вычислить, зная лишь её текст.
С индексами ячеек дело обстоит сложнее. Без связи с таблицей и ячейками невозможно найти значение,
соответствующее индексу. Дерево для вычислений воспринимает операнд как просто литерал,
а не указатель на ячейку. Сам по себе, без связи с таблицей, он не имеет никакого вычислительного смысла.
Подумайте, откуда дерево FormulaAST будет брать значения таких операндов.
В FormulaAST появился новый класс CellExpr : Expr. Это узел дерева, хранящий индекс ячейки.
Придумайте, как реализовать для него метод Evaluate(). То есть «‎научите» его находить нужную ячейку
с нужной формулой, зная лишь позицию ячейки. Если нужно, добавьте в класс поля и методы
или поменяйте сигнатуры — кроме интерфейсов.
Обратите внимание на интерфейс FormulaInterface из файла formula.h.

В нём метод Evaluate имеет новую сигнатуру, у метода есть аргумент — ссылка на таблицу:
    // Возвращает вычисленное значение формулы для переданного листа либо ошибку.
    // Если вычисление какой-то из указанных в формуле ячеек приводит к ошибке, то
    // возвращается именно эта ошибка. Если таких ошибок несколько, возвращается
    // любая.
    virtual Value Evaluate(const SheetInterface& sheet) const = 0;

Подумайте, откуда он будет поступать, куда и как затем передаваться.

2) Как будет работать граф зависимостей?

3) Как ячейка будет хранить информацию о своей принадлежности к графу? Какие поля и методы надо добавить
и куда (в какой/какие классы)?

В программе мы добавили в лексический анализатор следующее: когда пользователь задаёт
текст формульной ячейки в методе Cell::Set(), наш лексический анализатор возвращает
std::forward_list<Position> cells_ с индексами ячеек, входящих в формулу.
Как, имея эту информацию, встроить новую ячейку в граф зависимостей?
Что будет, если до вызова метода Cell::Set() ячейка была пустой?
Что будет, если она не была пустой, а содержала формулу с другими зависимостями и была встроена в граф?
Как изменение в ней повлияет на другие ячейки?

4) Как по графу зависимостей проверять циклические ссылки?
При вызове метода Sheet:SetCell(...) таблица должна проверить, что новая формула
не внесёт в таблицу циклических зависимостей между ячейками.
Как в этом поможет граф зависимостей?

5) Как реализовать кэш?
В каком виде будет реализован кэш? Когда и кем он будет вычисляться?
Как будет использоваться кэш при вычислении формулы в одной конкретной ячейке?
Как это повлияет на эффективность?
Если пользователь изменил некоторые ячейки в таблице, что произойдёт с кэшем во всех остальных ячейках таблицы?
Оцените эффективность (O-семантика) от введения кэша (до и после).

6) В какой последовательности должны работать новые методы при изменении ячейки?
Когда пользователь меняет/задаёт ячейку, все вышеперечисленное должно происходить в том или ином виде.
Подумайте, что и как должно происходить при вызове методов Cell::Set(std::string text)
и Sheet::SetCell(Position pos, std::string text).
Ответьте на вопрос, в какой последовательности ваши новые методы должны вызываться.

7) В каких классах какие методы должны располагаться?
Непосредственно дизайн классов.
Определите, каких полей и методов не хватает классам. Какой класс будет содержать поля и методы,
необходимые для того или иного действия.

--На проверку
1) На проверку пришлите заголовочные файлы классов Sheet, Cell, Formula и FormulaAST.
В них напишите сигнатуры всех необходимых публичных методов, а также поля членов класса,
которые отобразят взаимосвязь классов друг с другом. Ответьте для себя на вопросы,
что такое вершины и рёбра графа, как и где их хранить и почему нельзя обойтись без двух типов связей.

2) Приложите диаграммы алгоритмов:
    - Обход дерева формулы, которая вычисляет значение в конкретных ячейках - файл formula_calculation.pdf
    - Поиск цикл. завис-ей с оптимизац., обеспеч. проход по каждой ячейке только один раз - cyclic_dependencies.pdf
    - Инвалидация кэша и его оптимизация с проходом по ячейкам только один раз - cache_invalidation.pdf
    - Добавление новой ячейки, гарантирующее консистентное состояния таблицы - new_cell.pdf

Не забудьте указать, как вы планируете обрабатывать исключения.

Ответы на поставленные выше вопросы должны помочь вам разработать дизайн.
Рисовать диаграммы вы можете в любой удобной для вас программе. Мы советуем draw.io.

--Подсказка 1: Передача параметра
Чтобы передать параметр — скажем, ссылку на таблицу внутрь метода, можно использовать объекты-функции.
Например, функцию, которая по индексу ячейки возвращает её значение в конкретной таблице.

--Подсказка 2: Кэш
Чтобы не вычислять значения в ячейках лишний раз, можно хранить вычисленное значение в кэше. Например,
пользователь ввёл в ячейку E3 формулу “=C4*C2”. Чтобы её вычислить, нужны значения ячеек С2 и С4.
Если они уже когда-то были посчитаны, можно использовать эти значения.

Text:
        A       B       C       D       E
1
2        3           =A3/A2
3   =1+2*7                           =C4*C2
4                     =C2+8

Value:
        A       B       C       D       E
1
2        3               5
3       15                              65
4                       13

Вам надо продумать, что произойдёт с кэшем, если пользователь поменяет значения
в каких-нибудь ячейках таблицы. Например, если пользователь изменит формулу
в ячейке С3 с “=А3/А2” на “=1/А2”, то кэш в ячейках С4 и E3 перестанет отражать действительность
и станет ни на что не годным, то есть инвалидируется. Подумайте, что с этим делать.

Value:
        A       B       C       D       E
1
2        3              X
3       15                              X
4                       X

Text:
        A       B       C       D       E
1
2        3            =1/A2
3   =1+2*7                           =C4*C2
4                     =C2+8

Подсказка 3: Граф зависимостей ячеек
Ячейки зависят друг от друга. Это напоминает структуру данных графа. Фактически ячейки образуют граф зависимостей.
Граф состоит из узлов и рёбер. В программах обычно определяют класс «‎узел» графа,
содержащий набор указателей на другие узлы, с которыми он соединён рёбрами.
Если вы представите ячейки не только как элементы таблицы, но и как узлы графа,
сможете находить циклические зависимости, инвалидировать кэш и более эффективно вычислять формулы.

--Как будет тестироваться ваше решение
Ревьюеры проверят разработанный вами дизайн на предмет правильности, эффективности и элегантности решения.
Как только ваш дизайн станет со всех сторон прекрасен, вы сможете приступить к реализации, то есть начнёте кодить.

--Задание ("Таблица")
Реализуйте структуру данных «Электронная таблица». Интерфейс таблицы SheetInterface вы найдёте в файле common.h.
common.h содержит интерфейсы классов FormulaInterface, CellInterface, объявление структур Size и Position,
описание исключений и ошибок. Интерфейс SheetInterface не содержит методов удаления и вставки.
Реализовывать их не нужно.
Для размера минимальной печатной области в файле common.h определена структура Size.
В файле structures.cpp из решения первой задачи реализуйте operator= для этой структуры.
--Ограничения
Вносите изменения только в файлы sheet.h, sheet.cpp и structures.cpp. В файле structures.cpp
реализуйте Size::operator=().
--Как будет тестироваться ваш код
Протестируем только файлы sheet.h и sheet.cpp. Мы не будем тестировать остальные файлы.
Примеры тестов вы найдёте в файле main.cpp.
Мы будем проводить нагрузочные тесты: создавать/удалять большое количество ячеек много раз
и проверять время работы и использование памяти.
Проверим, что минимальная видимая область находится корректно.
Также будем проверять все функции интерфейса SheetInterface.
Скопируйте содержимое файлов main.cpp и common.h ниже и вставьте в своё решение.
--Подсказка
Разберёмся с ограничениями на производительность. Метод GetCell() должен отрабатывать за константное время,
в то время как ограничения на время работы для вставки и удаления столбцов/строк самые либеральные.
Значит, операции произвольного доступа будут вызываться чаще, чем операции вставки.
Наверно, имеет смысл использовать простую структуру данных вроде вектора векторов.
*/
